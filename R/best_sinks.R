#' Find best sinks
#'
#' @details
#' This function will loop through the offspring to find best sinks.
#'
#' @param possible_parents A list of integers, output from
#'     find_possible_parents.
#' @param ms Numeric vector, node scores for no parents. Output of
#'     no_parent_score. Should have same number of elements as variables in
#'     data.
#' @param possible_offspring A list of integers, output from
#'     find_possible_offspring.
#' @param pps Possible parent sets, output from `find_possible_parent_sets`.
#' @param bps A list of best possible parent set, output from
#'     `best_possible_parent_sets`.
#' @param max_parents Numeric, maximal number of parents.
#'
#' @return a data.frame with 4 variables, wscore, windx, k, sink.
#' @noRd
find_best_sinks <- function(possible_parents, ms, possible_offspring, pps, bps, max_parents) {
  m <- length(possible_parents)
  nms <- c("windx", "k", "sink", "wscore")
  sinks.tmp <- as.data.frame(matrix(NA, nrow = 0, ncol = length(nms)))
  names(sinks.tmp) <- nms

  # best sinks and scores for subnetworks of one node, which is the node itself
  # and its score
  for (s in 1:m) {
    sinks.tmp[s, "windx"] <- subsetr(m, s)
    sinks.tmp[s, "k"] <- 1
    sinks.tmp[s, "sink"] <- s
    sinks.tmp[s, "wscore"] <- ms[s]
  }
  mysinks <- sinks.tmp
  bsinks <- sinks.tmp[0, ]

  # best sinks and scores for subnetworks of size 2:m
  for (k in 2:m) {

    sinks.tmp1 <- list()

    ws <- numeric(nrow(sinks.tmp))
    for (j in 1:nrow(sinks.tmp)) {
      ws[j] <- length(subsetur(m, sinks.tmp[j, "windx"]))
    }

    total_length <- sum(ws)
    wscore <- windx <- k <- sink <- numeric(m * m) #find better upper bound

    index <- 1
    for (j in seq_len(nrow(sinks.tmp))) {
      w                    <- subsetur(m, sinks.tmp[j, "windx"])
      w.networkscore       <- sinks.tmp[j, "wscore"]
      w1sinks              <- wsink_scores(w, w.networkscore, possible_parents,
                                           possible_offspring, pps, bps, m, max_parents)
      index_subset         <- seq_along(w1sinks$wscore) - 1 + index
      wscore[index_subset] <- w1sinks$wscore
      windx[index_subset]  <- w1sinks$windx
      k[index_subset]      <- w1sinks$k
      sink[index_subset]   <- w1sinks$sink
      index                <- index + length(index_subset)
    }
    sinks.tmp1  <- data.frame(wscore = wscore[seq_len(index - 1)],
                              windx  = windx[seq_len(index - 1)],
                              k      = k[seq_len(index - 1)],
                              sink   = sink[seq_len(index - 1)])

    # break k loop if there are no more offspring for any sets
    if (nrow(sinks.tmp1) == 0) break

    # for each w, find the best sinks
    myws <- unique(sinks.tmp1$windx)
    for(wind in 1:length(myws)){
      myw    <- myws[wind]
      tmp    <- sinks.tmp1[is.element(sinks.tmp1$windx, myw), ]
      tmp1   <- tmp[tmp$wscore >= max(tmp$wscore), ]
      bsinks <- rbind(bsinks, tmp1)
    }
    bsinks <- unique(bsinks)
    sinks.tmp <- bsinks[is.element( bsinks$k, k), ]
  }

  return(bsinks[is.finite(bsinks$wscore), ])
}

#' Calculate sw score
#'
#' @details
#' given a node s, and a set w, compute score for s with its best parent set in
#' w argument bps is generated by pp_sets_bs
#'
#' @param s Integer, node id.
#' @param w Integer vector, vertices.
#' @param pp List of possible parents. A list of integers, output from
#'     find_possible_parents.
#' @param pps Possible parent sets, output from `find_possible_parent_sets`.
#' @param bps A list of best possible parent set, output from
#'     `best_possible_parent_sets`.
#'
#' @return List with two values.
#' @noRd
swscore <- function(s, w, pp, pps, bps, max_parents) {
  # find possible parents of s in w
  pset <- w[is.element(w, pp[[s]])]
  if (length(pset) > max_parents) {
    return(list(Inf, Inf))
  }
  aa <- vapply(pps[[s]], function(x) setequal(x, pset), FUN.VALUE = logical(1))

  out <- vector("list", 2)
  out[[1]] <- bps[[1]][[s]][aa][[1]]
  out[[2]] <- bps[[2]][[s]][aa][[1]]
  out
}

#' Calculate wsink score
#'
#' @details
#' Given a set w of nodes, compute network scores for all possible sinks of
#' sets, w1 = {w union v}, where v is a possible offspring of at least one of
#' the nodes in w. w_networkscore is the score of the best network for w.
#'
#' @param w Integer vector, vertices.
#' @param w_networkscore Numeric, network score.
#' @param pp List of possible parents. A list of integers, output from
#'     find_possible_parents.
#' @param po A list of integers, output from
#'     find_possible_offspring.
#' @param @param pps Possible parent sets, output from `find_possible_parent_sets`.
#' @param bps A list of best possible parent set, output from
#'     `best_possible_parent_sets`.
#' @param m Numeric, number of variables.
#'
#' @return A list with 4 variables, wscore, windx, k, sink.
#' @noRd
wsink_scores <- function(w, w_networkscore, pp, po, pps, bps, m, max_parents) {

  # Find possible offspring for w not already in w
  wpo <- integer()
  for (v in w) {
    wpo <- unique(c(wpo, po[[v]][!is.element(po[[v]], w)]))
  }

  if (length(wpo) > 0) {
    windx <- k <- sink <- wscore <- numeric(length(wpo))
    # Expand w by one po node, a possible sink, and compute score
    rowno <- 1
    for (s in wpo) {
      s_score <- swscore(s, w, pp, pps, bps, max_parents)[[2]]
      wscore[rowno] <- s_score + w_networkscore
      windx[rowno] <- subsetr(m, c(w, s))
      k[rowno] <- length(w) + 1
      sink[rowno] <- s
      rowno <- rowno + 1
    }
  } else {
    w1sinks <- list(
      wscore = integer(),
      windx = integer(),
      k = integer(),
      sink = integer()
    )
    return(w1sinks)
  }

  w1sinks <- list(
    wscore = wscore,
    windx = windx,
    k = k,
    sink = sink
  )
  return(w1sinks)
}
