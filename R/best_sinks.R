#' Find best sinks
#'
#' @details
#' This function will loop through the offspring to find best sinks.
#'
#' @param possible_parents A list of integers, output from
#'     find_possible_parents.
#' @param ms Numeric vector, node scores for no parents. Output of
#'     no_parent_score. Should have same number of elements as variables in
#'     data.
#' @param possible_offspring A list of integers, output from
#'     find_possible_offspring.
#' @param pps Possible parent sets, output from `find_possible_parent_sets`.
#' @param bps A list of best possible parent set, output from
#'     `best_possible_parent_sets`.
#' @param max_parents Numeric, maximal number of parents.
#'
#' @return a data.frame with 4 variables, wscore, windx, k, sink.
#' @noRd
find_best_sinks <- function(possible_parents, ms, possible_offspring, pps,
                              bps, max_parents) {
  m <- length(possible_parents)

  bsinks <- create_sink_list(list(), numeric(), numeric(), numeric(), m)

  # best sinks and scores for subnetworks of one node, which is the node itself
  # and its score
  sinks_tmp <- sink_score_one_node(m, ms)

  for (k in 2:m) {
    sinks_tmp1 <- create_sink_list(list(), numeric(), numeric(), numeric(), m)

    temp_new_rows <- map2(
      .x = sinks_tmp$windx[seq_len(attr(sinks_tmp, "index"))],
      .y = sinks_tmp$wscore[seq_len(attr(sinks_tmp, "index"))],
      .f = ~ wsink_scores(.x, .y, possible_parents, possible_offspring, pps,
                          bps, m, max_parents)
      )

    sinks_tmp1 <- append_sink_list(
      sinks_tmp1,
      purrr::flatten(purrr::map(temp_new_rows, "windx")),
      purrr::flatten_dbl(purrr::map(temp_new_rows, "k")),
      purrr::flatten_dbl(purrr::map(temp_new_rows, "sink")),
      purrr::flatten_dbl(purrr::map(temp_new_rows, "wscore"))
    )

    # For each w in sinks_tmp1, find best sinks
    vals <- unique(
      unlist(
        map(unique(sinks_tmp1$windx), ~ max_wscore(.x, sinks_tmp1))
        )
      )

    bsinks <- append_sink_list(bsinks,
                               windx = sinks_tmp1$windx[vals],
                               k = sinks_tmp1$k[vals],
                               sink = sinks_tmp1$sink[vals],
                               wscore = sinks_tmp1$wscore[vals])

    bsinks <- remove_dublicates(bsinks)

    sinks_tmp <- set_sink_list(
      sinks_tmp,
      bsinks$windx[bsinks$k == k],
      bsinks$k[bsinks$k == k],
      bsinks$sink[bsinks$k == k],
      bsinks$wscore[bsinks$k == k]
    )
  }

  bsinks
}



#' Calculate sw score
#'
#' @details
#' given a node s, and a set w, compute score for s with its best parent set in
#' w argument bps is generated by pp_sets_bs
#'
#' @param s Integer, node id.
#' @param w Integer vector, vertices.
#' @param pp List of possible parents. A list of integers, output from
#'     find_possible_parents.
#' @param pps Possible parent sets, output from `find_possible_parent_sets`.
#' @param bps A list of best possible parent set, output from
#'     `best_possible_parent_sets`.
#'
#' @return List with two values.
#' @noRd
swscore <- function(s, w, pp, pps, bps, max_parents) {
  # find possible parents of s in w
  pset <- w[is.element(w, pp[[s]])]
  if (length(pset) > max_parents) {
    return(list(Inf, Inf))
  }
  aa <- map_lgl(pps[[s]], ~setequal(.x, pset))

  out <- vector("list", 2)
  out[[1]] <- bps[[1]][[s]][aa][[1]]
  out[[2]] <- bps[[2]][[s]][aa][[1]]
  out
}

#' Calculate wsink score
#'
#' @details
#' Given a set w of nodes, compute network scores for all possible sinks of
#' sets, w1 = {w union v}, where v is a possible offspring of at least one of
#' the nodes in w. w_networkscore is the score of the best network for w.
#'
#' @param w Integer vector, vertices.
#' @param w_networkscore Numeric, network score.
#' @param pp List of possible parents. A list of integers, output from
#'     find_possible_parents.
#' @param po A list of integers, output from
#'     find_possible_offspring.
#' @param @param pps Possible parent sets, output from
#'     `find_possible_parent_sets`.
#' @param bps A list of best possible parent set, output from
#'     `best_possible_parent_sets`.
#' @param m Numeric, number of variables.
#'
#' @return A list with 4 variables, wscore, windx, k, sink.
#' @noRd
wsink_scores <- function(w, w_networkscore, pp, po, pps, bps, m, max_parents) {

  # Find possible offspring for w not already in w
  wpo <- integer()
  for (v in w) {
    wpo <- unique(c(wpo, po[[v]][!is.element(po[[v]], w)]))
  }

  if (length(wpo) > 0) {
    k <- sink <- wscore <- numeric(length(wpo))
    windx <- list()
    # Expand w by one po node, a possible sink, and compute score
    rowno <- 1
    for (s in wpo) {
      s_score <- swscore(s, w, pp, pps, bps, max_parents)[[2]]
      wscore[rowno] <- s_score + w_networkscore
      windx[[rowno]] <- c(w, s)
      k[rowno] <- length(w) + 1
      sink[rowno] <- s
      rowno <- rowno + 1
    }
  } else {
    w1sinks <- list(
      wscore = integer(),
      windx = list(),
      k = integer(),
      sink = integer()
    )
    return(w1sinks)
  }

  w1sinks <- list(
    wscore = wscore,
    windx = windx,
    k = k,
    sink = sink
  )
  return(w1sinks)
}

max_wscore <- function(myw, sinks_tmp) {
  index <- which(map_lgl(sinks_tmp$windx, ~setequal(.x, myw)))
  index_max <- sinks_tmp$wscore[index] >= max(sinks_tmp$wscore[index])
  index[index_max]
}
