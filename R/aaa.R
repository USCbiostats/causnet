# Compute index r for some set T, which is a subset of a set with n elements
# watch out for rounding errors!!!
subsetr = function(n, T){
  r = 0L
  for(i in seq_len(n)){
    if( is.element(i, T)) r = r + 2L ^ (n - i)
  }
  return(r)
}

# Find a subset set T of a set with n elements, using index r
# watch out for rounding errors!!!
subsetur = function(n, r){
  T = NULL
  for(i in n:1){
    if( (r %% 2) == 1 ) T = c(i,T)
    r = r %/% 2
  }
  return( T )
}

# function to find possible parents
mypp = function(mydata, alpha, n.var){
  pp = vector('list', n.var)
  for(v in 1:n.var){
    for(p in 1:n.var){
      if(p != v){
        p.value = cor.test(mydata[, v], mydata[, p])$p.value
        if(p.value < alpha) pp[[v]] = c(pp[[v]], p)
      }
    }
  }
  return(pp)
} # end mypp

# function to reformat a list of possible parents, pp, into a list of possible offspring, po
pofun = function(pp){
  po = vector('list', length(pp))
  for(i in 1:length(pp)){
    for(j in 1:length(pp)){
      if( is.element(i, pp[[ j ]]) ) po[[i]] = c( po[[i]], j )
    }
  }
  return( po )
}

# create list object with all combinations of vec
comb1 = function(vec) {
  n = length(vec)
  out = vector('list', n)
  for (j in 1:n) {
    if( length(vec) > 1 ) out[[ j ]] = combn(vec, j) else out[[ j ]] = matrix(vec, nrow=1, ncol=1)
  }
  return(out)
}

## create all sets of possible parents for each node
pp.sets = function(pp){
  n = length(pp)
  pps = vector('list', n)
  for(j in 1:n){
    pps[[ j ]] = comb1( pp[[ j ]] )
  }
  return(pps)
}

# Bigger is better score for node y and parents x
score.bic.lm = function(y, x, mydat) {
  y.nm = colnames(mydat)[ y ]
  if( is.element(x[1], 1:ncol(mydat)) ) x.nms = colnames(mydat)[ x ] else x.nms = "1"
  fit = lm(paste0(y.nm, ' ~ ', paste(x.nms, collapse=' + ')), dat=mydat)
  bic = -(1/2)*BIC(fit)
  return(bic)
}

## create object with scores for all sets of possible parents for each node
pp.sets.s = function(mydata, pps){
  n = length(pps)
  ppss = vector('list', n) # possible parent set scores
  ppss1 = vector('list', n) # possible parent best sets
  ppss2 = vector('list', n) # possible parent best set scores
  for(v in 1:n){
    n.pp = ncol(pps[[v]][[1]])
    for(set.size in 1:n.pp){
      ppss[[v]][[set.size]] = rep(NA, ncol(pps[[v]][[set.size]]) )
      ppss1[[v]][[set.size]] = rep(NA, ncol(pps[[v]][[set.size]]) )
      ppss2[[v]][[set.size]] = rep(NA, ncol(pps[[v]][[set.size]]) )
      for(pset.i in 1:ncol(pps[[v]][[set.size]])){
        v.pset = pps[[v]][[set.size]][ , pset.i ]
        ppss[[v]][[set.size]][ pset.i ] = score.bic.lm( v, v.pset, mydata )
      }
    }
  }
  return(ppss)
}

# compute scores for nodes with no parents
mscores = function(vset, mydata){
  mscore = NULL
  for(v in vset){
    mscore = c(mscore, score.bic.lm( v, NA, mydata ))
  }
  return(mscore)
}

# get a score, given a node, its parent set, and parent set scores
# ms = scores of nodes w/ no parents
get.score = function(v, pset, pps, ppss, ms){
  if(length(pset) < 1){
    myscore = ms[v]
  } else {
    l = length(pset)
    aa = apply(pps[[v]][[l]],2,setequal,y=pset)
    myscore = ppss[[v]][[l]][ aa ]
  }
  return(myscore)
} # end get.score

# function to find best parent set of s, for parent set pset, given pps, ppss, ms
bestps = function(v, pset, pps, ppss, ms){
  # all subsets of pset
  best.score = get.score(v, NULL, pps, ppss, ms)
  best.set = NULL
  sb = comb1( pset )
  for(j in 1:length(sb)){
    for(k in 1:ncol(sb[[j]])){
      tmp.set = sb[[j]][, k]
      tmp.score = get.score(v, tmp.set, pps, ppss, ms)
      if( tmp.score > best.score ){
        best.set = tmp.set
        best.score  = tmp.score
      }
    }
  }
  outp = vector('list', 2)
  outp[[1]] = best.set
  outp[[2]] = best.score
  return(outp)
} # end function bestps

# Get BEST parent sets and scores for all sets of possible parents for each node
pp.sets.bs = function(pps, ppss, ms){
  bps = ppss # best parent sets
  bpss = ppss # best parent set scores
  for(v in 1:length(pps)){
    # for each possible parent set, compare score w/ all subsets to identify the best possible parent sets
    n.pp = ncol(pps[[v]][[1]])
    for(set.size in 1:n.pp){
      n.sets = ncol(pps[[v]][[set.size]])
      bps[[v]][[set.size]] = vector('list', n.sets)
      for(k in 1:n.sets){
        tmp.set = pps[[v]][[set.size]][, k]
        tmp = bestps(v, tmp.set, pps, ppss, ms)
        bps[[v]][[set.size]][[k]] = tmp[[1]]
        bpss[[v]][[set.size]][k] = tmp[[2]]
      }
    }
  }
  outp = vector('list', 2)
  outp[[ 1 ]] = bps
  outp[[ 2 ]] = bpss
  return( outp )
} # end function pp.sets.bs

# given a node s, and a set w, compute score for s with its best parent set in w
# argument bps is generated by pp.sets.bs
swscore = function(s, w, pp, pps, bps){
  # find possible parents of s in w
  pset = w[ is.element( w, pp[[s]] ) ]
  l = length(pset)
  aa = apply(pps[[s]][[l]],2,setequal,y=pset)
  best.ps = bps[[1]][[s]][[l]][aa]
  best.pss = bps[[2]][[s]][[l]][aa]
  outp = vector('list', 2)
  outp[[ 1 ]] = best.ps
  outp[[ 2 ]] = best.pss
  return(outp)
} # end swscore

# Given a set w of nodes, compute network scores for all possible sinks of sets, w1 = {w union v},
#   where v is a possible offspring of at least one of the nodes in w.
# W.networkscore is the score of the best network for w.
wsink.scores = function(w, w.networkscore, pp, po, pps, bps, m){

  # Find possible offspring for w not already in w
  wpo = NULL
  for(v in w){
    wpo = unique( c(wpo, po[[v]][ !is.element( po[[v]], w ) ]) )
  }

  if( length(wpo) > 0 ){
    windx <- k <- sink <- wscore <- numeric(length(wpo))
    # Expand w by one po node, a possible sink, and compute score
    rowno = 1
    for(s in wpo){
      s.score = swscore(s, w, pp, pps, bps)[[2]]
      wscore[rowno] = s.score + w.networkscore
      windx[rowno] = subsetr(m, c(w, s))
      k[rowno] = length(w) + 1
      sink[rowno] = s
      rowno = rowno + 1
    }
  } else {
    w1sinks = NULL    # end if length(wpo)
    return( w1sinks )
  }

  w1sinks <- list(wscore = wscore,
                  windx = windx,
                  k = k,
                  sink = sink)
  return( w1sinks )
} # end wsink.scores
# w1sinks is a dataframe in including w1 indices, sink names, and w1 scores

# function to loop through offspring to find best sinks
bestSinks = function(pp, ms, po, pps, ppss, bps, mydata){
  m = length(pp)
  nms = c("windx", "k", "sink", "wscore")
  sinks.tmp = as.data.frame(matrix(NA, nrow=0, ncol=length(nms)))
  names(sinks.tmp) = nms

  # best sinks and scores for subnetworks of one node, which is the node itself and its score
  for(s in 1:m){
    sinks.tmp[s, "windx"] = subsetr(m, s)
    sinks.tmp[s, "k"] = 1
    sinks.tmp[s, "sink"] = s
    sinks.tmp[s, "wscore"] = ms[s]
  }
  mysinks = sinks.tmp
  bsinks = sinks.tmp[0, ]

  # best sinks and scores for subnetworks of size 2:m
  for(k in 2:m){

    sinks.tmp1 = list()

    for(j in 1:nrow(sinks.tmp)){
      w = subsetur(m, sinks.tmp[j, "windx"])
      w.networkscore = sinks.tmp[j, "wscore"]
      w1sinks = wsink.scores(w, w.networkscore, pp, po, pps, bps, m)
      sinks.tmp1[[j]] = as.data.frame(w1sinks)
    }
    sinks.tmp1 <- do.call(rbind, sinks.tmp1)

    # break k loop if there are no more offspring for any sets
    if( nrow(sinks.tmp1) == 0 ) break

    # for each w, find the best sinks
    myws = unique( sinks.tmp1$windx )
    for(wind in 1:length(myws)){
      myw = myws[ wind ]
      tmp = sinks.tmp1[ is.element( sinks.tmp1$windx, myw ), ]
      tmp1 = tmp[ tmp$wscore >= max(tmp$wscore), ]
      bsinks = rbind( bsinks, tmp1 )
    }
    bsinks = unique(bsinks)
    sinks.tmp = bsinks[ is.element( bsinks$k, k ), ]
  }

  return(bsinks)
} # end bestSinks

bestnet = function(bsinks, m){
  nms = c("windx", "k", "sink", "component")
  bestnets = as.data.frame(matrix(NA, nrow=0, ncol=length(nms)))
  names(bestnets) = nms

  ## Order best sinks, removing a sink at each step
  # Loop over connected components
  mycomp = 1
  rowno = 1
  while(nrow(bsinks) > 0){

    ks = unique( bsinks$k )
    ks = ks[order(ks, decreasing=TRUE)]
    k = max(ks)
    aa = match(k, bsinks$k)
    tmp.s = bsinks[ aa, ]
    bestnets[rowno, c("windx", "k", "sink")] = tmp.s[1, c("windx", "k", "sink")]
    bestnets[rowno, "component"] = mycomp
    myw = subsetur(m, tmp.s[1, "windx"])
    w1 = myw[ !is.element(myw, tmp.s[1, "sink"]) ]
    w1indx = subsetr(m, w1)

    rowno = rowno + 1
    wlen = length(w1)
    for(d in wlen:2){
      aa = match(w1indx, bsinks$windx)
      tmp.s = bsinks[ aa, ]
      bestnets[rowno, c("windx", "k", "sink")] = tmp.s[1, c("windx", "k", "sink")]
      bestnets[rowno, "component"] = mycomp
      w = subsetur(m, tmp.s[1, "windx"])
      w1 = w[ !is.element(w, tmp.s[1, "sink"]) ]
      w1indx = subsetr(m, w1)
      rowno = rowno + 1
    }

    # remove all rows in bsinks with sets that have elements of the largest w in bestnets
    aa = NULL
    for(j in 1:nrow(bsinks)){
      wj = subsetur(m, bsinks[j, "windx"])
      aa = c(aa, sum( is.element(wj, myw) ) == 0)
    }
    bsinks = bsinks[aa, ]
    mycomp = mycomp + 1
  } # end while loop

  return(bestnets)
} # end bestnet

# get edges of best network connected components from ordered sinks
sink2net = function(bnets, pp, pps, bps){
  m = length(bps[[1]])
  nms = c("node.source", "node.sink", "component")
  mynets = as.data.frame(matrix(NA, nrow=0, ncol=length(nms)))
  names(mynets) = nms
  n.comp = length(unique(bnets$component))
  rowno = 1
  for(c in 1:n.comp){
    tmpn = bnets[ is.element(bnets$component, c), ]
    for(k in max(tmpn$k):2){
      bp.set = NULL
      tmp = tmpn[ is.element(tmpn$k, k), ]
      s = tmp[ 1, "sink"]
      w = subsetur(m, tmp[ 1, "windx"])
      bp.set = swscore(s, w, pp, pps, bps)[[1]]
      if(!is.null(bp.set[[1]])){
        src = bp.set
        snk = rep(s, length(bp.set))
        cmp = rep(c, length(bp.set))
        mynets[ rowno:(rowno+length(bp.set)-1),] = cbind(src, snk, cmp)
        rowno = rowno+length(bp.set)
      }
    }
  }
  return(mynets)
} # end sink2net
